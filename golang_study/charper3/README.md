# Часть 3. Фундаментальные типы данных

Go предлагает ряд способов организации данных с широким спектром типов данных, на одном конце которого находятся **типы**, соотвествующие возможностям аппаратного обеспечения, а на другом - все, что нужно для того, чтобы программистам было удобно представлять сложные структуры данных.

Типы:
* фундаментальные
* составные или агрегированные
* ссылочные
* интерфейсы

Фундаментальные типы данной главы включают:
* числа
* строки
* булевы значения

Составные типы:
* массивы
* структуры, которые образуют более сложные типы данных путём объединения простых

Ссылочные представляют собой разнородную группу:
* указатели
* срезы
* отображения
* функции
* каналы

но общим у ссылочных типов является то, что все они обращаются к переменным или состояниям программы *косвенно*, так что **результат действия операции, применимой к одной ссылке, наблюдается всеми её копиями.**

## Целые числа

Знаковые: `int8, int16, int32, int64`
Беззнаковые: `uint8, uint16, uint32, uint64`

Есть также просто `int` и `uint` (либо 4 байта, либо 8 байт - определяется компилятором).

### Символы Юникода

Тип `rune` является **синонимом** для типа `int32` и по соглашению указывает, что данное значение является символом `Unicode`.

Эти два имени могут использоваться взаимозаменяемо.

## Синонимы

Аналогично тип `byte` является синонимом тирп uint8 **и подчеркивает, что это значения является фрагментром неформатированных данных**.

Имеется также беззнаковый тип `uintptr`, его ширина не определена, но достаточна для хранения всех битов значения указателя.

## Арифм.,лог. операции и операции сравнения в порядке уменьшения приоритета

1) `*`, `/`, `%`, `<<`, `>>`, `&`, `&^`,
2) `+`, `-`, `|`, `^`, 
3) `==`, `!=`, `<`, `<=`, `>`, `>=`,
4) `&&`,
5) `||`

Есть **5** уровней приоритета для бинарных оператором. Операторы на одном и том же уровне *левоассоциативны*, поэтому для ясности и для того, чтобы действия выполнялись в нужном порядке, могут быть необходимы скобки, как, например, в выражении наподобие:
```go
mask & (1 << 28) // операторы & и << находятся на одном уровне приоритетов, поэтому необходимы скобки
``` 

## Арифметические операции

Арифметические операции (`*`, `/`, `+`, `-`) могут применяться к целым числам, числам с плавающей точкой и *комплексным* числам, но оператор получения остатка при делении `%` **может применяться только к целым числам**.

Поведение `%` для отрицательных чисел в языке Go: **получает остаток с тем же знаком, как и знак делимого**. Например:
-5%3 и -5%-3 == -2 для обоих вариантов.

Поведение оператора `/` зависит от того, **являются ли его операнды целыми числами**, так что: `5.0/4.0 = 1.25`, но `5/4 = 1`, так как при целочисленном делении происходит усечение результата по направлению к нулю.

*Если результат операции, как знаковый, так и беззнаковый имеет больше битов, чем может быть представлено типом результата* - мы говорим о **переполнении**. **При этом старшие биты, которые не помещаются в результат, просто отбрасываются**.

```go
var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"
var i int8 = 127
fmt.Println(i, i+1, i*i)
```

## Побитовые операции

**Оператор `^`** представляет собой побитовое **исключающее ИЛИ** (XOR) при использовании в качестве бинарного оператора, но при использовании в качестве **унарного** оператора - **это уже будет побитовое отрицание или дополнение**. 

Оператор `&^` является **оператором сброса бита**. Пример: `z = x &^ y`; каждый бит z = 0, если соотвествующий бит у `y` равен `1`, **в противном случае он равен соотвествующему биту x**.

`0b1111 &^ 0b0101 = 0b1111 & 0b1010 = 0b1010`

Аналог этого в языке Си:

```C
#define MASK 0b0101

x &= ~(MASK) // x = 1111; x' = 1111 & (1010) = 1010 => x' = 1010
```

Приведённый ниже код показывает, как можно использовать битовые операции для интерпретации значения `uint8` в качестве компактного и эффективного набора восьми независисых битов. Он использует символы преобразования `%b` в `Printf` для вывода двоичных цифр числа; `08` уточняет поведение `%b`, заставляя дополнять результат нулями так, чтобы выводилось 8 цифр.

```go
var x uint8 = 1 << 1 | 1 << 5
var y uint8 = 1 << 1 | 1 << 2

fmt.Printf("%08b\n", x) // 00100010, множество {1,5}
fmt.Printf("%08b\n", y) // 00000110, множество {1,2}
fmt.Printf("%08b\n", x&y) // 00000010, пересичение {1}
fmt.Printf("%08b\n", x|y) // 00100110, объединение {1,2,5}
fmt.Printf("%08b\n", x^y) // 00100100, симметричная разность {2,5}
fmt.Printf("%08b\n", x&^y) // 00100000, разность {5}

for i := uint(0); i < 8; i++ {
    // Проверка принадлежности множеству
    if x&(1<<i) != 0 {
        fmt.Println(i) // "1", "5"
    }
}

fmt.Printf("%08b\n", x<<1) // "01000100", множество {2,6}
fmt.Printf("%08b\n", x>>1) // "00010001", множество {0,4}
```

Арифметически, сдвиг влево `x<<n` эквивалентен умножению на `2^n`, а сдвиг вправо - делению на `2^n`.

Сдвиг `<<` заполняет освобождающие биты нулями так же, как и сдвиг вправо `>>` **беззнакового значения**; 

для **знаковых значений**, сдвиг `>>` заполняет освободишиеся биты теми же значениями, что и значение знакового бита !! 

По этой причине, при рассмотрении целых чисел в качестве битового шаблона важно использовать **беззнаковую арифметику**.

### форматированный вывод чисел

При выводе чисел с использованием пакета fmt мы можем управлять системой счисления и форматом вывода с помощью символов преобразования `%d`, `%о` и `%х`, как показано в следующем примере:

```go
о := 0666
fmt.Printf("%d %[1]o %#[1]o\n", о) // "438 666 0666"
х := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Вывод:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```

`[1]` - это говорит о том, что функция Printf должна использовать `x` - первый операнд снова и снова.

Литералы записываются как символ в одинарных кавычках. Простейший при­мер с использованием `ASCII`-символа — `'а'`, но так можно записать любой символ `Unicode` — либо непосредственно, либо с помощью числовых управляющих последо­вательностей, как мы вскоре увидим. Руны выводятся с помощью символов преобразования `%с`, или `%q` — если требу­ются кавычки:

```go
ascii := 'а'
Unicode := '★'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", Unicode) // "9733 ★ '★'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
```

## Числа с плавающей точкой

Тип `float32` обеспечивает приблизительно `6` десятичных цифр точности, в то время как точность, обеспечиваемая типом `float64`, составляет около `15` цифр; тип `float64` в большинстве случаев следует предпочитать типу `float32`, поскольку при использовании последнего, если не принимать специальные меры, быстро накап­ливается ошибка, а **наименьшее положительное целое число, которое не может быть представлено типом float32**, не очень велико:

```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

Числа с плавающей точкой могут быть записаны буквально, с использованием де­сятичной записи:
```go
const е = 2.71828 // (Приблизительно)
```

В записи могут быть опущены цифры перед десятичной точкой (`.707`) и после нее (`1.`). Очень малые и очень большие числа лучше записывать с использованием научного формата, с буквой `е` или `Е `перед десятичной степенью:

```go
const Avogadro = 6.02214129е23
const Planck   = 6.62606957е34
```

Значения с плавающей точкой удобно выводить с помощью символов преобразо­вания `%g` функции `Printf`, которые выбирают наиболее компактное представление значения с надлежащей точностью, но для таблиц данных могут оказаться предпо­чтительнее символы преобразования `%е` (с показателем степени) или `%f` (без показа­теля степени). Все три варианта символов преобразования позволяют указывать ши­рину поля и числовую точность:

```go
for х := 0; х < 8; х++ {
    fmt.Printf("х = %d е` = %8.3f\n", х, math.Exp(float64(x)))
}

/*
х = 0 е` = 1.000
х = 1 е` = 2.718
х = 2 е` = 7.389
х = 3 е` = 20.086
х = 4 е` = 54.598
х = 5 е` = 148.413
х = 6 е` = 403.429
х = 7 е` = 1096.633
*/
```

Если функция, которая возвращает в качестве результата значение с плавающей точкой, может привести к ошибке или сбою, об этом лучше сообщать отдельным воз­вращаемым значением, как показано ниже:

```go
func compute() (value float64, ok bool) {
    // ...
    if failed {
        return 0, false
    }
    return result, true
}
```

## Комплексные числа

В go есть числа двух размеров: complex64 и complex128, компонентами которых являются два числа float32 и float64 соотвественно.

Встроенная функция complex создаёт комплексное число из действительной и мнимой компоненты, а встроенные функции real и imag извлекают эти компоненты:

```go
var х complexl28 = complex(1, 2) // 1+2i
var у complexl28 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(5+10i)"
fmt.Println(real(x*y))           // "5"
fmt.Println(imag(x*y))           // "10"

// другие способы инициализации комплексных чисел
x1 := 1 + 2i
y1 := 3 + 4i 
```

Пакет `math/cmplx` предоставляет библиотечные функции для работы с комплексными числами, такие как комплексный квадратный корень или возведение в степень:

```go
fmt.Println(cmplx.Sqrt(-1)) // "(0 + 1i)" 
```

### Булевы значения

Go предоставляет тип `bool` для объявления булевой переменной, которая имеет значение `true` или `false`.

Булевы значения могут объединяться с помощью операторов `&&` и `||`, с помощью которых делаются сокращенные вычисления - если два булевых выражения объединены в `&&`, то при если первое выражения ложно, второе вычисляться не будет, например:

```go
s != "" && s[0] == "x"
```

Выражение s[0] приведёт к сбою программы при применении к пустой строке.

Поскольку, `&&` имеет более высокий приоритет, то для выражения ниже не требуются никакие скобки:

```go
if 'а' <= с && с <= 'z' ||
   'А' <= с && с <= 'Z' ||
   '0' <= с && с <= '9' {
    // ...ASCII-буква или цифра...
}
```

Не существует неявного преобразования булева значения в числовое, равное 0 или 1 или обратно - из чисел в bool. Необходимо использоватья явную инструкцию if, как показано ниже:

```go
i := 0
if b {
    i = 1
}
```

При частой необходимости, можно обернуть этот код в функцию:

```go
// btoi возвращает 1, если b равно true, и 0, если false,
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
```

Обратная симметрия:

```go
func itob(i int) bool {
    return i != 0
}
```


### Строки

Строка - это неизменяемая часть байтов. Строки могут содержать произвольные данные, в том числе байты со значением `0`. Но обычно они содержат удобочитаемый для человека текст. Традиционно текстовые строки интерпретируются как последовательность символов Unicode в кодировке UTF-8.

Встроенная функция `len` возвращает количество байтов в строке, а операция индексирования `s[i]` возвращает i-ый байт строки s, где `0 <= i < len(s)`

```go
s := "hello world"

fmt.Println(len(s))     // "12"
fmt.Println(s[0], s[7]) // "104 119"
c := s[len(s)]          // ошибка: индекс вне диапазона
```

Операция получения подстроки `s[i:j]` даёт новую строку, состоящую из байтов исходной строки, начиная с индекса `i` и до (но не включая) байта с индексом `j`.

Результирующая строка содержит (j - i) байтов. **Если j меньше i, то возникает аварийная ситуация**.

**Строги допускают операцию конкатенации, но по своему свойству они - неизменяемы**, поэтому нельзя сделать так:
```go
s[0] = 'L' // ошибка компиляции: нельзя изменять строки
```

Неизменяемость означает, что две копии одной строки могут использовать одну и ту же память, что делает **копирование** - очень **дешёвой** операцией.

#### Строковые литералы

строковый литерал - это последовательность байтов, заключенная в кавычки.

Здесь по умолчанию, мы можем включать символы Unicode в строковые литералы.

Служебные строковые литералы начинаются с символа "обратный слэш". Вот последовательность строковых литералов:

```go
"\a"  // звуковой сигнал
"\b"  // перевод каретки на новую строку 
"\f"  // перевод страницы
"\n"  // новая страница
"\r"  // возврат каретки
"\t"  // табуляция
"\v"  // вертикальная табуляция
"\'"  // символ одинарной кавычки
"\""  // символ двойной кавычки
"\\"  // символ обратного слэша
```

Неформатированный строковый литерал - это символ `...`, внутри которого весь текст интерпретируется "как есть":

```go
const goUsage = `Go - инструмент для работы с исходным текстом Go.
Использование:
go команда [аргументы]`
```

#### Unicode

Для большинства задач тех вре­мен символов ASCII было достаточно, но большая часть населения мира при этом была лишена возможности пользоваться собственными системами письменности в компьютерах. С ростом Интернета данные на многочисленных языках стали гораздо более распро­страненным явлением. Каким же образом можно работать со всем этим богатым ма­териалом, причем работать по возможности эффективно?

Ответом на этот вопрос является `Unicode` (`Unicode.org`), в котором собраны все символы из всех мировых систем письменности плюс разнообразные символы ударений и прочие диакритические знаки.

Каждому такому символу назначен стандартный номер - код символа Unicode, или, в терминалогии Go - *руна* (тип `rune`)

Кодировка UTF-8 оказывается исключительно удобной в качестве формата обмена данными, но в пределах программы руны могут оказаться более удобными, посколь­ку имеют одинаковый размер и, таким образом, легко индексируются в массивах и срезах.

Преобразование `[]rune`, примененное к строке в кодировке `UTF-8`, возвращает
последовательность символов `Unicode`, закодированную в этой строке:
```go
// Слово "программа", записанное по-японски на катакане
s := // *здесь 5 иероглифов*
fmt.Printf("% x\n",s) //"еЗ 83 97 еЗ 83 ad еЗ 82 Ь0 еЗ 83 а9 еЗ 83 а0"
г := []rune(s)
fmt.Printf("%x\n",г) //"[30d7 30ed 30b0 30e9 30e0]"
fmt.Println(string(r)) // *здесь снова 5 иероглифов*
```

Поскольку строки неизменяемы, инкрементное простроение строк может включать огромное количество выделений памяти и копирований. В таких случая эффективным является использование типа `bytes.Buffer`

### Константы, перечисления

Константы представляют собой компилятору, значения которых известны заранее для того, чтобы компилятор смог вычислить эти значения. Базовым типом константы может быть только фундаментальный тип: строка, число, логическое значение

```go
const pi = 3.14159 // лучшим приближением к числу pi является math.Pi
```

Как и в случае переменных, в одном объявлении может находиться несколько констант:
```go
const (
    e = 2.718281
    pi = 3.14159
)
```
многие вычисления констант могут быть завершены сразу во время компиляции.

Результатами арифметических и логических операций также являются константы.

Таким образом, обе объявленные ниже константы имеют тип `time.Duration`, что показывают символы преобразования `%Т` (от слова `Type`):
```go
const noDelay time.Duration = 0
const timeout = 5 * time.Minute
fmt.Printf("%T %[1]v\n", noDelay) // "time.Duration 0"
fmt.Printf("%T %[1]v\n", timeout) // "time.Duration Sm0s"
fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration lm0s"
```

Если последовательность констант объявлена в виде группы, выражения с правой стороны от символа `=` может быть опущено для всех констант, кроме первой. При этом подразумевается, что в текущей константе без явно указанного выражения будут использованы значения и тип предыдущего выражения, например:

```go
const (
    а = 1
    b
    с = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
```
#### Генератор констант iota или перечисления

Объявление `const` может использовать генератор констант `iota`, который при­меняется для создания последовательности связанных значений без их явного указа­ния. В объявлении `const` значение `iota` начинается с нуля и увеличивается на еди­ницу для каждого элемента в последовательности.

Вот пример из пакета `time`, который определяет именованные константы типа `Weekday` для дней недели, начиная с нуля для `Sunday`. Типы такого рода часто име­нуются *перечислениями*.

```go
type Weekday int
const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```
Это определение объявляет `Sunday` как `0`, `Monday` как `1` и т.д.

Можно использовать `iota` и в более сложных выражениях, как в приведенном да­лее примере из пакета `net`, где каждому из младших пяти битов целого беззнакового числа присваивается уникальное имя.

```go
type Flags uint
const (
    FlagUp Flags = 1 << iota // is up
    FlagBroadcast
    FlagLoopback
    FlagPointToPoint
    FlagMulticast
)
```
С увеличением `iota` каждая константа получает значение `1 << iota` (т.е. полу­чается последовательность возрастающих степеней двойки), каждое из которых соот­ ветствует одному отдельному биту. Эти константы можно использовать в функциях, которые выполняют установку, сброс или проверку одного или нескольких битовых флагов.

```go
func IsUp(v Flags) bool { return v & FlagUp == FlagUp }
func TurnDown(v *Flags) { *v &^= FlagUp }
func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
func IsCast(v Flags) bool { return v & (FlagBroadcast|FlagMulticast) != 0 }

func main() {
    var v Flags = FlagMulticast | FlagUp
    fmt.Printf("%b %t\n", v IsUp(v)) // "10001 true"
    TurnDown(Sv)
    fmt.Printf("%b %t\n", v, IsUp(v)) // "10000 false"
    SetBroadcast(&v)
    fmt.Printf("%b %t\n", v, IsUp(v)) // "10010 false"
    fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
}
```

В качестве еще более сложного примера применения `iota` ниже показано объяв­ление имен для степеней значения `1024`:
```go
const (
    _ = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776          (превышает 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424 (превышает 1 << 64)
    YiB // 1208925819614629174706176
)
```

#### Нетипизированные константы

Некоторые константы могут не иметь тип.
Компилятор представляет эти не привязанные к типу константы с гораздо большей числовой точностью, чем значения фундаментальных типов, а их арифметика является более точной, чем машинная; можно предположить по крайней мере 256-битовую точность (32 байтовую).

Имеется шесть вариантов таких несвязанных констант, именуемых *нетипизированиым булевым значением*, *нетипизированным целым чис­лом*, *нетипизированной руной*, *нетипизированным числом с плавающей точкой*, *не­типизированным комплексным числом* и *нетипизированной строкой*.

Пример использования нетипизированной константы.
```go
var х float32    = math.Pi
var у float64    = math.Pi
var z complex128 = math.Pi
```

Вспомните, что оператор `/` может представлять в зависимости от операндов как целочисленное деление, так и деление с плавающей точкой. Следовательно, выбор литерала может повлиять на результат выражения константного деления:
```go
var f float64 = 212
fmt.Println((f-32)*5/9)     // "100"; (f-32)*5 имеет тип float64
fmt.Println(5/9*(f-32))     // "0"; 5/9 - нетипизированное целое (0)
fmt.Println(5.0/9.0*(f-32)) // "100"; 5.0/9.0 - нетипизированное значение с плавающей точкой
```

Когда *нетипизированная кон­станта* находится **в правой части объявления переменной с явным указанием типа**, как в первой инструкции приведенного ниже исходного текста, **или присваивается переменной**, как в следующих трех инструкциях, константа ***неявно преобразуется*** в тип этой переменной, если такое преобразование возможно:
```go
var f float64 = 3 + 0i // Нетипизированное комплексное в правой части преобразуется в float64
f = 2                  // Нетипизированное целое в правой части преобразуется в float64
f = 1e123              // Нетипизированное действительное в правой части преобразуется в float64
f = 'a'                // Нетипизированная руна в правой части преобразуется в float64
```
Эти выражения эквивалентны следующим: 
```go
var f float64 = float64(3 + 0i)
f = float64(2)
f = float64(1e123)
f = float64('a')
```
**Явное** или **неявное**, преобразование константы из одного типа в другой требует, чтобы **целевой тип** (цель - тип в левой части) мог представлять **исходное значение**. Округление допускается для действительных и комплексных чисел с плавающей точкой.

```go
const (
    deadbeef = 0xdeadbeef // Нетипизированный int = 3735928559
    а = uint32(deadbeef)  // uint32 = 3735928559
    b = float32(deadbeef) // float32 = 3735928576 (округление)
    с = float64(deadbeef) // float64 = 3735928559 (точное)
    d = int32(deadbeef)   // Ошибка: переполнение int32
    e = float64(1e309)    // Ошибка: переполнение float64
    f = uint(-1)          // Ошибка: число в скобках нельзя представить как uint
)
```
