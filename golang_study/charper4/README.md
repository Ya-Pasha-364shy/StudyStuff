Глава 4 про **массивы** и **составные типы** данных.

# Массивы

**Массив представляет собой последовательность фиксированной длины из нуля или более элементов определенного типа**. **Из-за фиксированной длины** массивы редко используются в Go непосредственно. *Срезы, которые могут увеличиваться и умень­шаться, являются гораздо более гибкими*, но, чтобы понять срезы, сначала следует разобраться в массивах.

*Доступ к отдельным элементам массива осуществляется с помощью обычных обозначений индексирования*, значения индексов в которых имеют значения в диапазоне `[0, len(array))`

```go
var а [3]int // Массив из трех целых чисел
fmt.Println(a[0]) // Вывод первого элемента
fmt.Println(a[len(a)-1]) // Вывод последнего элемента, а[2]
```

Вывод значений индексов и элементов:
```go
for i, v := range а {
    fmt.Printf("%d %d\n", i, v)
}

// вывод только элементов

for _, v := range а {
    fmt.Printf("%d\n", v)
}
```

**По-умолчанию элементам массива изначально присваиваются нулевые значения типа элемента** (для чисел это значение 0). Для инициализации мас­сива списком значений можно использовать **литерал массива**:
```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

Если в литерале массива на месте длины находится троеточие, то длина массива определяется числом инициализаторов этого массива. Например:
```go
q := [...]int{1,2,3,4,5} 
fmt.Printf("%T\n", q)
```

Размер массива является ЧАСТЬЮ его типа, поэтому `[3]int != [4]int` (типы различны). Размер массива должен быть **константным варажением**, то есть таким, которое можно вычислить во время компиляции программы.
```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // Ошибка компиляции: нельзя присвоить `[4]int` переменной типа `[3]int`
```

Как мы увидим, **синтаксис литерала для массивов, срезов, отображений и структур­** подобен. Выше используется упорядоченный список значений, но можно также указать список пар "индекс-значение":

```go
type Currency int
const (
    USD Currency = iota
    EUR
    GBP
    RUR
)

symbol := [...]string{USD:"$" EUR:"€", GBR:"£", RUR:"₽"}
fmt.Println(RUR, symbol[RUR]) // "3 ₽"
```

Как и прежде, неуказанные значения получают нулевое значение типа элемента. Например,
```go
г := [...]int{99:-1}
```
Определяет массив с именем `r` из `100` элементов, среди которых ненулевыми является только последний элемент, значение которого равно `-1`.

**Если тип элемента** массива является *сравниваемым*, то таким же является и **тип массива**, так что мы можем сравнить два массива такого типа непосредственно, с по­мощью оператора `==`, сообщающий, все ли соответствующие элементы массивов равны. Оператор `!=` является отрицанием оператора `==`.

```go
а := [2]int{1, 2}
b := [...]int{1, 2}
с := [2]int{1, 3}
fmt.Println(a == b, a == с, b == с) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // Ошибка компиляции: разные типы "[2]int" и "[3]int"
```

Для того, чтобы не передавать массив как аргумент, потому что в таком случае, каждое значение по индексу в аргументе скопируется в соотвествующий индекс в параметр самой функции, можно передавать массив с помощью указателя (ака по-ссылке).

Приведенная ниже функция заполняет нулями содержимое массива `[32]byte`:
```go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```

Литерал массива `[32]byte{}` дает нам массив из `32` байтов. Каждый элемент мас­сива имеет нулевое значение для типа `byte`, которое просто равно нулю. Мы можем
использовать этот факт для написания другой версии функции `zero`:
```go
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```

Применение указателя на массив оказывается эффективным и позволяет вызыва­емой функции изменять переменные вызывающей функции, **но массивы остаются негибким решением** из-за присущего им фиксированного размера. Например, функ­ция `zero` не примет указатель на переменную `[16]byte`; нет также никакого спосо­ба *добавления или удаления элементов массива*. *По этим причинам, за исключением особых случаев, таких как хеш **SHA256** фиксированного размера, массивы в качестве
параметров функции используются редко; вместо этого обычно используются срезы.

# Срезы

Тип среза записывается как `[]Т`, где `Т` — тип эле­ментов среза; он выглядит как тип массива без указания размера.
Массивы и срезы тесно связаны. **Срез — это легковесная структура данных**, кото­рая предоставляет доступ к **подпоследовательности** элементов массива (или, возмож­но, ко всем элементам), известного как **базовый массив**. Срез состоит из трех компо­нентов: **указателя**, **длины** и **емкости**.

Пусть дан массив элементов типа `string` из `13` элементов, то есть его тип `[13]string`:
```go
months := [...]string{ 1 : "Январь", /*...*/, 12: "Декабрь" }
```
так что *январь* соответствует элементу `months[1]`, а *декабрь* — `months[12]`.

*Оператор среза* `s[i:j]` создаст новый **срез**, где `0 <= i <= j <= cap(s)`, который создаёт новый срез, ссылающийся на элементы последовательности `s` с элемента индекса `i` по элемент с индексом `j-1` включительно.

Примечательно то, что размер среза можно динамически увеличить на значение, не превышающее `capacity`, которое определяется как разность между длиной массива и первого индекса в операторе среза + 1: `s[i:j]`. То есть `capacity = len(array) - i + 1`.

```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2) // ["Апрель" "Май" "Июнь"]
fmt.Println(summer) // ["Июнь" "Июль" "Август"]
```

*"Срезание"* за пределами `cap(s)` вызывает аварийную ситуацию, а срезание за пределами `len(s)` приводит к расширению среза, так что результат может быть длиннее оригинала:
```go
fmt.Println(summer[:20])
endlessSummer := summer[:5] // Расширение среза (в пределах диапазона) (до пяти элементов - действует как summer[6:11] // 6+5 = 11) 
fmt.Println(endlessSummer) // "[Июнь Июль Август Сентябрь Октябрь]"
```

Поскольку срез содержит указатель на элемент массива, то передача среза в функцию в качестве аргумента, передаёт именно указатель, позволяющий изменять содержимое переданного среза в вызванной функции.

В отличие от массивов, **срезы не являются сравниваемыми** !
Чтобы проверить, содержат ли два среза одинаковые эле­менты. Для сравнения двух срезов байтов (`[]byte`) стандартная библиотека предо­ставляет высокооптимизированную функцию `bytes.Equal`, но для других типов срезов необходимо выполнять сравнение самостоятельно:
```go
func equal(x, у []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

Есть две причины, по которым проверка глубокой эквивалентности является про­блематичной:
* во-первых, в отличие от элементов массива, элементы среза являются *косвенными*, что позволяет срезу содержать самого себя;
* во-вторых, в силу *косвенности* элементов **фиксированное значение среза может содержать различные элементы в разные моменты времени** при изменении содер­жимого базового массива.

Массивы не изменяют свою фиксированную длину, а срезы могут изменить, поэтому тут возникает проблема тождественности операторов `==` для массивов и срезов.

Единственным разрешенным сравнением среза является сравнение с `nil`:
```go
if summer == nil {
    // ...
}
```
Такой срез не имеет базового массива. И длина, и ёмкость такого среза равны нулю. Но нулевыми `len` и `cap` могут также обладать и ненулевые срезы, такие как `[]int{}` или `make([]int,3)[3:]`

Как и в случае любого типа, который может иметь значение `nil`, это значение для конкретного среза можно записать с помощью выражения преобразования, такого
как `[]int(nil)`:
```go
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
```

Так что, если вам нужно проверить, **является ли срез пустым**, используйте про­верку `len(s) == 0`, но не `s == nil`. За исключением сравнения со значением `nil`.

Встроенная функция `make` создает срез с определенным типом элементов, длиной и емкостью. Аргумент, указывающий емкость, может быть опущен, и в таком случае емкость принимается равной длине:
```go
make([]T, len)
make([]T, len, cap) // то же, что и make([]T, cap)[:len]
```

За кулисами функция `make` создает неименованную переменную массива и воз­вращает его срез. Сам массив доступен только через возвращаемый срез.
**В первом случае - срез является представлением всего массива целиком**.
Во втором - **срез является представлением только первых `len` его элементов**, но его емкость включает в себя весь массив.

## функция `append`

эта встроенная функция добавляет элементы в срез:
```go
var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H', 'e', 'l', 'l', 'o', ' ', '世', '界']"
```
Цикл использует функцию `append` для построения среза из десяти рун, закодиро­ванных строковым литералом, хотя данная конкретная задача решается куда проще с помощью встроенного преобразования: `[]rune("Hello, 世界")`

Эта функция имеет решающее значение для понимания работы срезов. Вот версия `append` под названием `appendInt`, которая специализирована для срезов типа `[]int`.

```go
func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen <= cap(x) {
        // место ещё есть, расширяем срез
        z = x[:zlen]
    } else {
        // места для роста нет. Выделяем новый МАССИВ. Увеличиваем в два раза 
        // для линейной амортизированной сложности
        zcap := zlen
        if zcap < 2 * len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap) // а кулисами функция `make` создает неименованную переменную МАССИВА и воз­вращает его СРЕЗ. Сам массив доступен только через возвращаемый срез.
        copy(z, x)
    }
    z[len(x)] = y
    return z
}
```

Функция `сору` возвращает количество фактически скопированных элементов, которое представляет собой меньшую из длин двух сре­зов, поэтому опасность выйти за пределы диапазона отсутствует.

Срезы могут относиться к одному и тому же базовому массиву; они могут даже перекрываться.

Обычно мы не знаем, **приведет ли данный вызов функции `append` к перераспределению памяти**, поэтому мы не можем считать ни что исход­ный срез относится к тому же массиву, что и результирующий срез, ни что он от­носится к другому массиву. Аналогично мы не должны предполагать, что операции над элементами старого среза будут (или не будут) отражены в новом срезе. Поэтому обычно выполняется присваивание результата вызова функции `append` той же пере­менной среза, которая была передана в функцию `append`:
```go
runes = append(runes, r)
```

Чтобы правильно использовать срезы, важ­но иметь в виду, что хотя элементы базового массива и доступны косвенно, указатель среза, его длина и емкость таковыми не являются.**Чтобы обновить их**, требуется при­сваивание, такое, как показано выше.

**Встроенная функция append** также может добавлять несколько элементов или даже целый их срез":

```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x) // добавления копии среза в срез
fmt.Println(x)   // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```

С помощью модификации, показанной ниже, можно обеспечить поведение нашей функции, совпадающее с поведением встроенной функции `append`:

```go
func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    if zlen > cap(x) {
        zcap := zlen
        if zcap < 2 * zlen {
            zcap = 2 * zlen
        }
        z = make([]int, zlen, zcap)
    } else {
        // место для расширения есть:
        z = z[:zlen]
    }
    copy(z[len(x):], y)
    return z
}
```

Троеточие `"..."` в объявлении функции appendInt делает её ***вариадической функцией***, то есть функцией с переменным числом аргументов, которое может принимать любое количество завершающих аргументов.

## работа со срезами "на месте"

То есть без переаллокации памяти. Смотреть файл `slices.go`, `exercises.go`

# Отображения (хэши)

Хеш-таблица является одной из самых гениальных и универсальных из всех структур данных. Это неупорядоченная коллекция пар "ключ-значение", в которой все ключи различны, а значение, связанное с заданным ключом, можно получить, об­новить или удалить с использованием в среднем константного количества сравнений ключей, независимо от размера хеш-таблицы.

В Go **отображение** представляет собой **ссылку на хеш-таблицу**. Тип отображения представляется как `map[K]V`, где `K` - это тип ключа, а `V` - это тип значения.
Тип ключей не обязан совпадать с типом значений.

Тип ключа должен быть сравниваемым с помощью оператора `==`, чтобы отображение (из коробки) могло проверить, равен ли данный ключ одному из имеющихся в нём. Хотя числа с плавающей точкой и являются сравниваемыми, сравнивать их - это всегда плохая идея, особенно если допустимое значение равно `NaN`.

Встроенная функция `make` может быть использована для создания отображения.
```go
ages := make(map[string]int)
```

Для создания нового отображения, заполненным данными, можно использовать *литерал* отображения:
```go
ages := map[string]int{
    "alice": 31,
    "charlie": 34,
}
```
Эта запись эквивалентна следующей:
```go
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```

Другая запись создания пустого отображения (не через make) имеет вид:
```go
ages := map[string]int{}
```

Обратиться к элементам отображения можно с помощью обычной индексации:
```go
ages["alice"] = 32
fmt.Println(ages["alice"]) // "32"
```

Удаление осуществляется с помощью встроенной функции `delete`:
```go
delete(ages, "alice") // Удаление элемента ages["alice"], то бишь удаляет "ключ-значение"
```
**Все эти операции безопасны, даже если элемент в отображении отсутствует**; при использовании ключа, которого нет в отображении, поиск возвращает нулевое зна­чение соответствующего типа. Так что, например, следующая инструкция работает, даже когда ключа `"bob"` еще нет в отображении, поскольку значение `ages["bob"]` в этом случае будет равно 0:
```go
ages["bob"] = ages["bob"] + 1 // С днем рождения!
```

*Элементы отображения не являются переменными*, и мы не можем полу­чить их адреса:
```go
_ = &ages["bob"] // Ошибка: невозможно получить адрес в отображении
```
**Потому что с ростом отображения может быть выполнено повторное хе­ширование элементов в новые места хранения, что потенциально делает адреса не­ действительными**.

Обход всех пар ключ-значение в хэшах:
```go
for name, age := range ages {
    fmt.Printf("%s\t%d\n", name, age)
}
```
**Порядок итераций по отображению не определен !** различные реализации могут использовать разных хэш-функции, что приведёт к иному порядку. На практике получается случайный порядок, который варьируется от одного запуска программы к другому.

Для перечисления пар "ключ-значение", используется функция сортировки из пакета `sort`, которая, например, может отсортировать ключи, если они являются строками:
```go
import "sort"

func main() {
    ages := map[string]int{
        "alice": 31,
        "charlie": 34,
    }
    var names []string

    for name := range ages {
        names = append(names, name)
    }
    sort.Strings(names)
    for _, name := range names {
        fmt.Printf("%s\t%d\n", name, ages[name])
    }
}
```

Поскольку мы знаем окончательный размер `names` с самого начала, более эффек­тивным решением является изначальное выделение массива требуемого размера. Приведенная далее инструкция создает срез, который изначально пуст, но обладает
достаточной емкостью для хранения всех ключей из отображения `ages`:
```go
names := make([]string, 0, len(ages)) // выделяем массив длинной 0, ёмкостью len(ages)
```

Нулевые характиристики хэша:
```go
var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
```

Большинство операций над отображениями, включая **поиск**, **delete**, **len** и **цикл по диапазону** - **безопасно выполняются *с нулевым отображением***, поскольку *оно ведет себя так же, как пустое отображение*. Однако сохранение значений в нулевом отобра­жении приводит к аварийной ситуации:
```go
ages["carol"] = 21 // Аварийная ситуация: присваивание элементу *нулевого* отображения !!!
```
Так как перед тем, **как выполнять присваивание, необходимо выделить память для отображения**.

Доступ к элементу отображения с помощью индексации всегда дает значение. Если ключ присутствует в отображении, вы получаете соответствующее значе­ние; если нет — вы получите нулевое значение типа элемента, как мы видели для `ages["bob"]`. Для многих целей это вполне нормально, но иногда нужно знать, есть ли некоторый элемент в отображении.
Например, если типом элемента является чис­ло, то отличить несуществующий элемент от элемента, который имеет нулевое значе­ние, можно с помощью следующего теста:
```go
age, ok := ages["bob"]
if !ok { /*" bob" не является ключом в данном отображении; age == 0 */ }
```
Зачастую две такие инструкции объединяются в:
```go
if age, ok := ages["bob"]; !ok { /* ... */ }
```
**Второе значение — это логическое значение, показывающее, имеется ли данный элемент в отображении**. Этой логической переменной часто дают имя `ok`, особенно если она сразу же исполь­зуется в условии инструкции `if`.

Как и срезы, отображения нельзя сравнивать одно с другим; единственным закон­ным сравнением является сравнение со значением `nil`.
```go
func equal(x, у map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, x_v := range x {
        // !ok == true        -> в хэше y нет значения с таким ключом !
        // y_v != x_v == true -> значения в хэшах x, y по одному и тому же ключу не совпадают !
        if у_v, ok := y[k]; !ok || y_v != x_v {
            return false
        }
    }
    return true
}
```

Если бы мы наивно написали `x_v != у[k]`, то показанный ниже вызов сообщил бы, что аргументы равны, хотя это и не так:
```go
// Истинно при некорректном написании функции
equal(map[string]int{"A": 0}, map[string]int{"B": 42})
```

Go не предоставляет тип `set`, но поскольку все ключи отображения различны, отображение может служить и для этой цели. Для иллюстрации программа ниже (`dedup`) считывает последовательность строк и выводит только первое вхождение каждой из различных строк. Программа `dedup` использует отображение, ключи которой представляют множество строк, которые уже встречались, и с его помощью обеспечивает отсут­ствие в выводе дубликатов строк:
```go
func main() {
    seen := make(map[string]bool) // Множество строк
    input := bufio.NewScanner(os.Stdin)
    for input.Scan {
        line := input.Text()
        // печатаем только уникальные строки сразу
        if !seen[line] {
            seen[line] = true
            fmt.Println(line)
        }
    }
    if err := input.Err(); err != nil {
        fmt.Fprintf(os.Stderr, "dedup: %v\n", err)
        os.Exit(1)
    }
}
```
Иногда такие отображения как выше называют множеством строк, так как строки в этом отображении укикальны и по-идее все имеют значение true.

**Иногда нужно такое отображение (или множество), ключи которого являются "срезами", но поскольку ключи отображений должны быть сравниваемыми, такое отображение не может быть выражено непосредственно** (не может существовать, т.к. срезы нельзя сравнивать друг с другом, только с `nil`). Однако, это можно сделать в 2 этапа.

Сначала определим функцию `k`, которая отображает ключ на строку. Она имеет такое свойство, что `k(x) == k(y) <==> x == y (имеют одинакую длину и все их пары ключ-значение совпадают)`.

```go
var m = make(map[string]int)

func k(list []string) string { return fmt.Sprintf("%q", list) }

func Add(list []string) { m[k(list)]++ }

func Count(list []string) int { return m[k(list)] }
```
Здесь берём срез, переводим его в строку с помощью функции `Sprintf` и интерпретируем возвращённое значение как строку. Эта строка - это ключ.
Такой же подход может использоваться для любого несравниваемого типа ключей, не только для срезов. Иногда этот подход полезен даже для ключей сравниваемых типов, когда требуется определение равенства, отличное от ==, например сравнение без учета регистра для строк. Тип `k(х)` также не обязан быть строкой; подойдут лю­бые сравниваемые типы с необходимым свойством эквивалентности, такие как целые числа, массивы или структуры.

Смотри `charcount.go`, `graph.go` чтобы увидеть отображения в действии.

# Структуры

Структура представляет собой агрегированный тип данных, объединяющий нуль или более именованных значений произвольных типов в единое целое. Каждое зна­чение называется полем.

Приведенные далее инструкции объявляют структурный тип `Employee` и пере­менную `dilbert`, которая является экземпляром `Employee`:
```go
type Employee struct {
    ID int
    Name string
    Address string
    DoB time.Time
    Position string
    Salary int
    ManagerlD int
}
var dilbert Employee
```

Доступ к отдельным полям `dilbert` осуществляется с помощью записи с точкой наподобие `dilbert.Name` или `dilbert.DoB`. Поскольку `dilbert` является перемен­ной, ее поля также являются переменными, так что им можно выполнять присваива­ние:
```go
dilbert.Salary -= 5000 // Зарплата снижена, пишет мало строк кода
```

Можно также получать их адреса и доступ посредством этих адресов:
```go
position := &dilbert.Position
*position = "Senior " + *position // Повышен в должности
```

**Запись с точкой работает и с указателями на структуры**:
```go
var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (активный участник команды)"
```
Последняя инструкция эквивалентна следующей:
```go
(*employeeOfTheMonth).Position += " (активный участник команды)"
```

Для заданного уникального идентификатора сотрудника функция `EmployeeByID` возвращает указатель на структуру `Employee`. Для доступа к ее полям можно исполь­зовать запись с точкой
```go
func EmployeeByID(id int) *Employee { /*...*/ }

fmt.Println(EmployeeByID(dilbert.ManagerID).Position) // Босс

id := dilbert.ID
EmployeeBylD(id).Salary = 0 // Уволить...
```

Поля обычно записываются по одному в строке; при этом имя поля предшествует его типу. Однако последовательные поля одного и того же типа могут быть объедине­ны, как поля `Name` и `Address` ниже:
```go
type Employee struct {
    ID int
    Address, Name string
    DoB time.Time
    Position string
    Salary int
    ManagerlD int
}
```

*Имя поля структуры экспортируется, если оно начинается с прописной буквы*; это основной механизм управления доступом в Go. **Структурный тип может содержать комбинацию экспортируемых и неэкспортируемых полей**.

Именованный структурный тип `S` не может объявить поле того же типа `S`: агрегат­ное значение не может содержать само себя. (Аналогичное ограничение применимо и к массивам). **Но S может объявить поле с типом указателя *S**, который позволяет нам создавать рекурсивные структуры данных, такие **как связанные списки и деревья**. Это проиллюстрировано в коде ниже, в котором для реализации сортировки вставками
используется бинарное дерево:

```go
type tree struct {
    value int
    left, right *tree
}

// Sort сортирует значения "на месте",
func Sort(values []int) {
    var root *tree
    for _, v := range values {
        root = add(root, v)
    }
    appendValues(values[:0], root)
}

// appendValues добавляет элементы t к values в требуемом
// порядке и возвращает результирующий срез,
func appendValues(values []int, t *tree) []int {
    if t != nil {
        values = appendValues(values, t.left) // сначала спустимся до самого левого узла, который есть в дереве, затем возьмем его значение, посмотрим правую часть, возьмем все, что справа, затем поднимимся на уровень выше по рекурсии и так до тех пор, пока не обойдем все дерево. Причём где-то в середине среза будет лежать сначение корня - получится отсортированный срез интов.
        values = append(values, t.value)
        values = appendValues(values, t.right)
    }
    return values
}

func add(t *tree, value int) *tree {
    if t == nil {
        // Эквивалентно возврату &tree{value: value},
        t = new(tree)
        t.value = value
        return t
    }
    if value < t.value {
        t.left = add(t.left, value)
    } else {
        t.right = add(t.right, value)
    }
    return t
}
```

Тип **структуры без полей** называется пустой структурой, записываемой как `struct{}`. Она имеет нулевой размер и не несет в себе никакой информации, **но мо­жет оказаться полезной**. Некоторые программисты Go используют ее вместо `bool` **в качестве типа значения в отображении**, которое представляет собой множество. *Такой выбор подчеркивает, что в отображении играют роль только ключи*; экономия памяти при этом оказывается незначительной, а синтаксис — **более громоздким, по­ этому мы, как правило, избегаем такого решения** !!!.
```go
seen := make(map[string]struct{}) // Множество строк
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}
    // ... s встречается впервые ...
}
```

## структурные литералы

Значение структурного типа может быть записано с использованием структурно­го литерала, который определяет значения своих полей:
```go
type Point struct{ X, Y int }
p := Point{1, 2} // структурный литерал Point{1, 2}
```
Такая разновидность чаще всего используется именно внутри пакета, так как использование такого литерала заставляет запомнить порядок полей и делает код подверженным ошибкам при добавлении новых полей в структурный тип.

Гораздо чаще используется вторая разновидность, в которой значение структуры инициализируется с помощью перечисления некоторых или всех имен полей с соот­ветствующими значениями:
```go
anim := gif.GIF{LoopCount: nframes} // `LoopCount` - это название поля, а `nframes` - это соотвествующее ей значение.
```

Если поле в таком литерале опущено, оно получает нулевое значение соответству­ющего типа. Поскольку в литерале указаны имена полей, их порядок становится не имеющим значения.
```go
/* файл p.go */
package р
type Т struct{ a, b int } // а и b не экспортируемы

/* файл q.go */
package q
import "р"
var _ = р.Т{а: 1, b: 2} // Ошибка компиляции: нельзя обращаться к а и b
var _ = р.Т{1, 2}       // Ошибка компиляции: нельзя обращаться к а и b
```

Значения структур могут быть переданы как аргументы в функцию и быть возвра­щены из нее. Например, приведенная далее функция масштабирует `Point` с исполь­зованием некоторого коэффициента:
```go
func Scale(p Point, factor int) Point {
    return Point{p.X * factor, p.Y * factor} // здесь возвращается именно значение для объекта, который будет жить дальше пока не закончится облась видимости вызвавшей функции
}
fmt.Println(Scale(Point{1, 2}, 5)) // ”{5 10}"
```

Для повышения эффективности большие структурные типы обычно передаются в функции или возвращаются из них косвенно с помощью указателя:
```go
func Bonus(e *Employee, percent int) int {
    return e.Salary * percent / 100
}
```

Такая передача обязательна, если функция должна модифицировать свой аргумент, поскольку при передаче по значению вызываемая функция получает только копию аргумента, а не ссылку на исходный аргумент.
```go
func AwardAnnualRaise(e *Employee) {
    е.Salary = е.Salary * 105 / 100
}
```

Поскольку работа со структурами очень часто выполняется через указатели, мож­но использовать следующую сокращенную запись для создания и инициализации структурной переменной и получения ее адреса:
```go
рр := &Point{1, 2}
```
Эта запись эквивалентна следующей:
```go
pp := new(Point)
*pp = Point{1, 2}
```

Однако `&Point{1, 2}` можно использовать и непосредственно в выражении, таком, как вызов функции.

## сравнение структур

Если все поля структуры сравниваемы, то сравниваема и сама структура, так что два выражения этого типа можно сравнить с помощью оператора `==` или `!=`. Опера­ция `==` поочередно сравнивает соответствующие поля двух структур, так что приве­денные ниже выражения сравнения эквивалентны:

```go
type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}

fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"
```

Сравниваемые структурные типы, как и любые сравниваемые типы, могут использо­ваться в качестве типа ключа в отображении:
```go
type address struct {
    hostname string
    port int
}
hits := make(map[address]int)
hits[address{"golang.org", 443}]++
```

# JSON

Запись объектов JavaScript (`JavaScript Object Notation` — `JSON`) является стандарт­ной записью для пересылки и получения структурной информации. `JSON` — не един­ственный способ такой записи. Аналогичной цели служат `XML` (раздел 7.14), `ASN.l` и `Google’s Protocol Buffers`, и каждый имеет свою нишу; однако из-за простоты, удо­бочитаемости и всеобщей поддержки наиболее широко используется именно `JSON`.

Go обладает превосходной поддержкой кодирования и декодирования этих форма­тов, предоставленной в пакетах стандартной библиотеки `encoding/json`, `encoding/xml`, `encoding/asnl` и других, и все эти пакеты имеют схожие `API`. В данном разде­ле приводится краткий обзор наиболее важных частей пакета `encoding/json`.

`JSON` является кодированием значений `JavaScript` — **строк, чисел, логических зна­чений, массивов и объектов — в виде текста в кодировке `Unicode`**. Это эффективное, но удобочитаемое представление фундаментальных типов данных.

```json
boolean true
number  273.15
string  "She said: 'Hello, World!\""
array   ["gold", "silver", "bronze"]
object  {"year":   1980,
         "event":  "archery",
         "medals": ["gold", "silver", "bronze"]}
```


Маршалинг:
```go
data, err := json.Marshal(movies) // преобразовать срез типа Movie в JSON
data, err := json.MarshalIndent(movies, "", " ") // преобразовать срез типа Movie в JSON - Человеко-читаемое
```
Обратная операция перевода из json в структуру называется - демаршалингом `json.Unmarshal`.
```go
var titles []struct{ Title string }
// ...
if err := json.Unmarshal(data, titles); err != nil {
    log.Fatalf("Сбой демаршалинга JSON: %s", err)
}
fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
```
